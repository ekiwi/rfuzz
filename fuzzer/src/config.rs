// Copyright 2018, Kevin Laeufer <laeufer@cs.berkeley.edu>

// this module contains code to load the fuzz configuration TOML
// which is generated by the FIRRTL instrumentation pass
// (and potentially extended/modified by hand)

use toml;
use serde_json;
use config::toml::value::Datetime;
use colored::*;
use prettytable::Table;
use prettytable::row::Row;
use prettytable::cell::Cell;

use std::fs::File;
use std::io::prelude::*;

use run::TestSize;
use analysis;

pub struct Config {
	size: TestSize,
	data: ConfigData,
}

impl Config {
	pub fn from_file(word_size: usize, filename: &str) -> Self {
		let mut file = File::open(filename).expect("failed to open config");
		let mut contents = String::new();
		file.read_to_string(&mut contents).expect("failed to read config");
		let data: ConfigData = toml::from_str(&contents).unwrap();
		let size = Config::determine_test_size(word_size, &data);
		let config = Config { size, data };
		config.validate();
		config
	}

	pub fn to_json(&self) -> String {
		serde_json::to_string(&self.data).expect("failed to serialize data!")
	}

	pub fn gen_ranges(&self) -> Vec<analysis::Range> {
		assert!(self.data.counter.iter().all(|c| c.width == 8));
		let first = CounterRangeProps::read(&self.data.counter[0]);

		let changes = self.data.counter.iter()
			.scan(first, |p, c| {
				let this = CounterRangeProps::read(&c);
				let change = *p != this;
				*p = this;
				Some((change, c.index, this))})
			.filter(|x| x.0)
			.map(|x| (x.1 as usize, x.2));

		let mut ranges = Vec::new();
		let mut range = first.range(0);
		for (ii, prop) in changes {
			range.stop = ii;
			ranges.push(range.clone());
			range = prop.range(ii);
		}
		range.stop = self.size.coverage;
		ranges.push(range.clone());
		ranges
	}

	fn determine_test_size(word_size: usize, data: &ConfigData) -> TestSize {
		let div_2_ceil = |a, b| (a + (b - 1)) / b;
		let to_bytes = |b| div_2_ceil(div_2_ceil(b, 8), word_size) * word_size;

		let input_bits : usize = data.input_bits() as usize;
		let coverage_bits : usize = data.counter.iter().map(|c| c.width as usize).sum();

		// the cycles count in front of every coverage entry takes 16bit
		let coverage = to_bytes(coverage_bits + 2 * 8) - 2;

		TestSize { input: to_bytes(input_bits), coverage }
	}

	fn validate(&self) {
		// make sure the size is large enough to hold coverage and inputs
		let input_bits : usize = self.data.input_bits() as usize;
		assert!(input_bits <= self.size.input * 8);
		let coverage_bits : usize = self.data.counter.iter().map(|c| c.width as usize).sum();
		assert!(coverage_bits <= self.size.coverage * 8);
	}

	pub fn get_test_size(&self) -> TestSize { self.size }

	pub fn get_inputs(&self) -> Vec<(String,u32)> {
		let mut ii = Vec::with_capacity(self.data.input.len());
		for field in &self.data.input {
			ii.push((field.name.clone(), field.width));
		}
		ii
	}

	pub fn coverage_signal_count(&self) -> usize {
		self.data.coverage.len()
	}

	pub fn print_header(&self) {
		println!("Fuzzing {}", self.data.general.top.bold());
		println!("Instrumented on:   {}", self.data.general.timestamp);
		println!("Coverage Signals:  {}", self.coverage_signal_count());
		println!("Input Fields:      {}", self.data.input.len());
		let width = self.data.input_bits();
		println!("Total Input Width: {}", width);
		println!("Allocated Bytes per Input:    {}", self.size.input);
		println!("Allocated Bytes for Coverage: {}", self.size.coverage);
	}

	pub fn print_inputs(&self, inputs: &[u8]) {
		let cycle_count = inputs.len() / self.size.input;
		assert_eq!(cycle_count * self.size.input, inputs.len());

		// print the inputs as a table! (one row per cycle)
		let mut table = Table::new();

		let mut head_row = vec![Cell::new("C")];
		for field in &self.data.input { head_row.push(Cell::new(&field.name)); }
		table.add_row(Row::new(head_row));

		// bits are labled left to right (the MSB is bit0!)
		let read_bit = |cycle: usize, bit: usize| -> char {
			let byte_ii = cycle * self.size.input + bit / 8;
			let byte = inputs[byte_ii];
			let bit_ii = 7 - (bit % 8);
			let is_set = (byte & (1 << bit_ii)) != 0;
			if is_set { '1' } else { '0' }
		};

		for cycle in 0..cycle_count {
			let mut row = vec![Cell::new(&cycle.to_string())];
			let mut bit = 0;
			for field in &self.data.input {
				let mut bit_str = String::with_capacity(field.width as usize);
				for _ in 0..field.width {
					bit_str.push(read_bit(cycle, bit));
					bit += 1;
				}
				row.push(Cell::new(&bit_str));
			}
			table.add_row(Row::new(row));
		}

		table.printstd();
		//println!("{:?}", inputs)
	}

	// New Config Notes
	// * for individual inputs, the coverage are actual counts
	//  -> display true count + false count
	// * for the bitmap, those counts are bucketed
	//  -> display how many bins are covered, e.g. `7/8`
	//  -> display which bins are covered, e.g. `00100101`
	//
	// ==> thus we should probably split this function into two for now
	//     instead of using the "inverted flag"

	// to be run on the raw coverage feedback from the fuzz server
	pub fn print_test_coverage(&self, coverage: &[u8]) {
		assert_eq!(coverage.len(), self.size.coverage);

		let mut table = Table::new();
		table.add_row(row!["count", "name", "type", "signal", "expression", "source location"]);

		for counter in self.data.counter.iter() {
			let count = coverage[counter.index as usize];
			let signal = &self.data.coverage[counter.signal as usize];
			let src = format!("{}:{}", signal.filename, signal.line);
			table.add_row(row![count, counter.name, signal.port, signal.name, signal.human, src]);
		}
		table.printstd();
	}

	// to be run on the binned coverage bitmap
	pub fn print_bitmap(&self, bitmap: &[u8]) {
		assert_eq!(bitmap.len(), self.size.coverage);

		let mut table = Table::new();
		table.add_row(row!["count", "bits", "name", "ii", "type", "signal", "expression", "source location"]);

		for counter in self.data.counter.iter() {
			let covd = bitmap[counter.index as usize];
			let signal = &self.data.coverage[counter.signal as usize];

			let max = 8 - analysis::bin(counter.max as u8).leading_zeros();
			let num = format!("{}/{}", covd.count_zeros(), max);
			let mask = ((1 << max) - 1) as u8;
			let bits = format!("{:08b}", (!covd) & mask);

			let src = format!("{}:{}", signal.filename, signal.line);
			let ii = format!("{}", counter.index);
			table.add_row(row![num, bits, counter.name, ii, signal.port, signal.name, signal.human, src]);
		}
		table.printstd();
	}
}

#[derive(PartialEq, Copy, Clone)]
struct CounterRangeProps {
	scale: bool,
	fail: bool,
}
impl CounterRangeProps {
	fn read(counter: &Counter) -> Self {
		CounterRangeProps { scale: counter.scale, fail: counter.fail }
	}
	fn range(&self, ii: usize) -> analysis::Range {
		analysis::Range { start: ii, stop: ii,
			do_scale: self.scale,
			is_fail: self.fail,
		}
	}
}

#[derive(Debug, Deserialize, Serialize)]
struct General {
	filename: String,
	instrumented: String,
	top: String,
	timestamp: Datetime
}
#[derive(Debug, Deserialize, Serialize)]
struct Coverage {
	port: String,
	name: String,
	index: i32,
	filename: String,
	line: i32,
	column: i32,
	human: String,
}
#[derive(Debug, Deserialize, Serialize)]
struct Input {
	name: String,
	width: u32,
}
#[derive(Debug, Deserialize, Serialize)]
struct Counter {
	name: String,
	width: i32,
	max: i32,
	scale: bool,
	index : i32,
	signal: i32,
	fail: bool,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct ConfigData {
	general: General,
	coverage: Vec<Coverage>,
	input: Vec<Input>,
	counter: Vec<Counter>,
}

impl ConfigData {
	fn input_bits(&self) -> u32 {
		self.input.iter().map(|ii| ii.width).sum::<u32>()
	}
}
